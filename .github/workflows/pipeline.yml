name: CI/CD Pipeline

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:

 # Build and Test
#  build-test:
#    runs-on: ubuntu-latest
#
#    services:
#      postgres:
#        image: postgres:latest
#        env:
#          POSTGRES_DB: testdb
#          POSTGRES_USER: testuser
#          POSTGRES_PASSWORD: testpass
#        options: >-
#          --health-cmd pg_isready
#          --health-interval 10s
#          --health-timeout 5s
#          --health-retries 5
#        ports:
#          - 5432:5432
#
#      mongodb:
#        image: mongo:7
#        env:
#          MONGO_INITDB_ROOT_USERNAME: mongo_test_user
#          MONGO_INITDB_ROOT_PASSWORD: mongo_test_pass
#        options: >-
#          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
#          --health-interval 10s
#          --health-timeout 5s
#          --health-retries 5
#        ports:
#          - 27017:27017
#
#    steps:
#      - name: Checkout code
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0
#
#      - name: Set up JDK 21
#        uses: actions/setup-java@v4
#        with:
#          java-version: '21'
#          distribution: 'temurin'
#          cache: 'maven'
#
#      - name: Cache Maven dependencies and build output
#        uses: actions/cache@v4
#        with:
#          path: |
#            ~/.m2
#            target  # Cache compiled classes to avoid full recompilation
#          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
#          restore-keys: |
#            ${{ runner.os }}-maven-
#
#      - name: Wait for PostgreSQL to be ready
#        run: |
#          echo "Waiting for PostgreSQL and database 'testdb' to be ready..."
#          for i in {1..30}; do
#          # Check if database exists
#          if PGPASSWORD=testpass psql -h localhost -U testuser -d testdb -c "SELECT 1" >/dev/null 2>&1; then
#          echo "âœ… Database 'testdb' is ready!"
#          break
#          fi
#          echo "Database not ready yet... attempt $i/30"
#          sleep 2
#          done
#
#      - name: Wait for MongoDB to be ready
#        run: |
#          echo "MongoDB..."
#          for i in {1..30}; do
#            if curl -s -o /dev/null -w "%{http_code}" http://localhost:27017/ | grep -q "200\|404"; then
#              echo "MongoDB is ready!"
#              break
#            fi
#            echo "MongoDB not ready yet... attempt $i/30"
#            sleep 2
#          done
#
#      - name: Run comprehensive quality checks
#        run: |
#          mvn clean verify \
#            spotbugs:check \
#            -Dspring.datasource.url=jdbc:postgresql://localhost:5432/testdb \
#            -Dspring.data.mongodb.uri=mongodb://localhost:27017/testdb
#        env:
#          MAVEN_OPTS: "-Duser.home=${{ runner.temp }}"
#          SPRING_PROFILES_ACTIVE: test
#          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb
#          SPRING_DATASOURCE_USERNAME: testuser
#          SPRING_DATASOURCE_PASSWORD: testpass
#          SPRING_DATA_MONGODB_URI: mongodb://mongo_test_user:$mongo_test_pass@localhost:27017/test_db?authSource=admin
#          MAIL_ADDRESS_USERNAME: test@email.test
#          MAIL_APP_PASSWORD: test test test test
#          APP_BASE_URL: http://localhost:8080
#          ADMIN_EMAIL: admin@mail.com
#          ADMIN_PASSWORD: admin_pass
#          ADMIN_NAME: admin
#          JWT_SECRET: test_jwt_secret
#          JWT_EXP: 50000
#          JWT_REFRESH_EXP: 150000
#          OTP_EXP: 600
#          OTP_LENGTH: 6
#          ALLOWED_ORIGINS: "*"
#
#      - name: Security scan with OWASP Dependency-Check
#        run: mvn org.owasp:dependency-check-maven:check -DfailBuildOnCVSS=7
#
#      - name: Upload test and quality reports
#        if: always()
#        uses: actions/upload-artifact@v4
#        with:
#          name: quality-reports
#          path: |
#            target/site/jacoco/
#            target/site/spotbugs.html
#            target/surefire-reports/
#            target/failsafe-reports/
#            target/dependency-check-report.html
#          retention-days: 30
#
#      - name: Check coverage threshold
#        if: success()
#        run: |
#          # Extract coverage percentage from JaCoCo XML (simplified check)
#          if [ -f target/site/jacoco/jacoco.xml ]; then
#            COVERAGE=$(grep -o 'line-rate="[0-9.]*"' target/site/jacoco/jacoco.xml | head -1 | sed 's/line-rate="//' | sed 's/"//')
#            MIN_COVERAGE=0.80  # 80% minimum coverage
#            if (( $(echo "$COVERAGE < $MIN_COVERAGE" | bc -l) )); then
#              echo "âŒ Coverage ($(echo "$COVERAGE*100" | bc)%) is below minimum ($(echo "$MIN_COVERAGE*100" | bc)%)"
#              exit 1
#            else
#              echo "âœ… Coverage ($(echo "$COVERAGE*100" | bc)%) meets minimum requirement"
#            fi
#          else
#            echo "âš ï¸ JaCoCo report not found"
#          fi

  # Build and Push Docker Image
#  build-push:
#    runs-on: ubuntu-latest
##    needs: build-test
#    permissions:
#      contents: read
#      packages: write
#    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
#
#    steps:
#      - name: Checkout code
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0
#      - name: Calculate next version
#        id: version
#        run: |
#          # Get current version from file (or start with 1.0.0)
#          if [ -f .version ]; then
#          CURRENT_VERSION=$(cat .version)
#          else
#          CURRENT_VERSION="1.0.0"
#          fi
#
#          # Parse version components
#          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
#
#          # Auto-increment patch version
#          NEW_PATCH=$((PATCH + 1))
#          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
#
#          # Save new version
#          echo "$NEW_VERSION" > .version
#
#          # Output for GitHub Actions
#          echo "VERSION=$NEW_VERSION" >> $GITHUB_ENV
#          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
#
#          echo "âœ… Version incremented: $CURRENT_VERSION â†’ $NEW_VERSION"
#
#      - name: Set up Docker Buildx
#        uses: docker/setup-buildx-action@v3
#
#      - name: Login to Docker Hub
#        uses: docker/login-action@v3
#        with:
#          username: ${{ secrets.DOCKER_USERNAME }}
#          password: ${{ secrets.DOCKER_PASSWORD }}
#
#      - name: Build and push Docker image with version tags
#        uses: docker/build-push-action@v5
#        with:
#          context: .
#          push: true
#          tags: |
#            anonto/hrms-backend:latest
#            anonto/hrms-backend:${{ env.VERSION }}
#            anonto/hrms-backend:${{ github.sha }}
#          labels: |
#            org.opencontainers.image.version=${{ env.VERSION }}
#            org.opencontainers.image.revision=${{ github.sha }}
#            cache-from: type=gha
#            cache-to: type=gha,mode=max
#
#      - name: Generate deployment payload
#        run: |
#          echo "IMAGE_TAG=anonto/hrms-backend:${{ env.VERSION }}" >> $GITHUB_ENV
#          echo "VERSION=${{ env.VERSION }}" >> $GITHUB_ENV
#          echo "TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
#
#      - name: Output image info
#        run: |
#          echo "ðŸŽ¯ Version: ${{ env.VERSION }}"
#          echo "ðŸ“¦ Image tags:"
#          echo "   - anonto/hrms-backend:latest"
#          echo "   - anonto/hrms-backend:${{ env.VERSION }}"
#          echo "   - anonto/hrms-backend:${{ github.sha }}"
#          echo "âœ… Image pushed to Docker Hub"

  # Deploy to vps
  deploy-production:
    runs-on: ubuntu-latest
#    needs: build-push
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: IMAGE_TAG
          script: |
            # Update the .env file with new image tag
            cd ~/hrms-deployment

            # Run deployment script
            echo "ðŸš€ Executing deployment script..."
            ./deploy.sh